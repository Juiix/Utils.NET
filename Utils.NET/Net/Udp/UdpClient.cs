using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Timers;
using Utils.NET.IO;
using Utils.NET.Logging;
using Utils.NET.Net.Udp.Packets;
using Utils.NET.Utils;

namespace Utils.NET.Net.Udp
{
    public abstract class UdpClient<TPacket> where TPacket : Packet
    {
        public enum ConnectStatus
        {
            Success,
            NoChallengeReceived,
            NoConnectedReceived,
            Disconnect
        }

        private enum ConnectionState
        {
            ReadyToConnect = 0,
            Connected = 1,
            AwaitingChallenge = 2,
            AwaitingConnected = 3,
            Disconnected = 4
        }

        private struct PacketHeader
        {
            /// <summary>
            /// The sequence id of this packet
            /// </summary>
            public ushort sequenceId;

            /// <summary>
            /// The last received sequence id
            /// </summary>
            public ushort lastReceivedId;

            /// <summary>
            /// Bitfield containing received sequence info
            /// </summary>
            public uint receivedBitfield;

            public PacketHeader(BitReader r)
            {
                sequenceId = r.ReadUInt16();
                lastReceivedId = r.ReadUInt16();
                receivedBitfield = r.ReadUInt32();
            }
        }

        /// <summary>
        /// The max size of a Udp packet
        /// </summary>
        private const int Max_Packet_Size = 512;

        /// <summary>
        /// The delay, is milliseconds, before resending a connection packet
        /// </summary>
        private const double Connection_Retry_Delay = 250;

#if DEBUG
        /// <summary>
        /// Percentage of simulated packet loss
        /// </summary>
        private const double Simulate_Packet_Loss_Percent = -1;
#endif

        /// <summary>
        /// The amount of times to resend a connection packet before failure
        /// </summary>
        private const int Connection_Retry_Amount = 10;

        /// <summary>
        /// Underlying system socket used to send and receive data
        /// </summary>
        private Socket socket;

        /// <summary>
        /// The EndPoint that this client is connecting or connected to
        /// </summary>
        private EndPoint remoteEndPoint;

        /// <summary>
        /// The state of the virtual connection
        /// </summary>
        private int state = 0;

        /// <summary>
        /// The current connection state of the client
        /// </summary>
        /// <value>The state.</value>
        private ConnectionState State => (ConnectionState)state;

        /// <summary>
        /// Factory used to create packets
        /// </summary>
        private PacketFactory<TPacket> packetFactory;

        /// <summary>
        /// Buffer used to hold received data
        /// </summary>
        private IO.Buffer buffer;

        /// <summary>
        /// Object used to sync sending states
        /// </summary>
        private object sendSync = new object();

        /// <summary>
        /// Bool determining if the client is currently sending
        /// </summary>
        private bool sending = false;

        /// <summary>
        /// Queue used to store data ready to send
        /// </summary>
        private Queue<UdpSendData> sendQueue = new Queue<UdpSendData>();

        /// <summary>
        /// Dictionary containing sent packets waiting for verification
        /// </summary>
        private ConcurrentDictionary<ushort, Packet> sentPackets = new ConcurrentDictionary<ushort, Packet>();

        /// <summary>
        /// Value used to syncronize disconnection calls
        /// </summary>
        private int disconnected = 0;

        /// <summary>
        /// The time that the last packet was sent
        /// </summary>
        private DateTime lastSent = DateTime.Now;

        /// <summary>
        /// The time that this client last received data
        /// </summary>
        private DateTime lastReceived = DateTime.Now;

        /// <summary>
        /// Salt generated locally
        /// </summary>
        private ulong localSalt;

        /// <summary>
        /// Salt generated by the server
        /// </summary>
        private ulong remoteSalt;

        /// <summary>
        /// Generated salt from server/client
        /// </summary>
        public ulong salt;

        /// <summary>
        /// Timer used to check timeouts and connection packet delivery
        /// </summary>
        private System.Timers.Timer timer;

        /// <summary>
        /// The amount of times a connection packet has been resent
        /// </summary>
        private int retryCount = 0;

        /// <summary>
        /// The local port that this client is bound to
        /// </summary>
        public int LocalPort => ((IPEndPoint)socket.LocalEndPoint).Port;

        /// <summary>
        /// The next packet sequence id
        /// </summary>
        private ushort nextSequenceId = 0;

        /// <summary>
        /// The last received sequence id
        /// </summary>
        private ushort lastReceivedSequenceId = 0;

        /// <summary>
        /// Bitfield representing received packets
        /// </summary>
        private uint receivedBitfield = 0;

        /// <summary>
        /// Object used to sync sequence work
        /// </summary>
        private object sequenceLock = new object();

        #region Init

        public UdpClient()
        {
            Init();
        }

        private void Init()
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

            packetFactory = new PacketFactory<TPacket>();
            buffer = new IO.Buffer(Max_Packet_Size);

            timer = new System.Timers.Timer(Connection_Retry_Delay / 2);
            timer.Elapsed += OnTimer;
        }

        public void SetConnectedTo(EndPoint endpoint, ulong salt, int localPort)
        {
            this.salt = salt;
            remoteEndPoint = endpoint;
            SetConnectionState(ConnectionState.Connected);
            socket.Bind(new IPEndPoint(IPAddress.Any, localPort));
        }

        #endregion

        #region Timer

        private void OnTimer(object sender, EventArgs e)
        {
            var s = State;
            switch (s)
            {
                case ConnectionState.Connected:

                    break;
                case ConnectionState.AwaitingChallenge:
                    if (CheckResend())
                    {
                        SendConnect();
                    }
                    else
                    {
                        ConnectFailed(ConnectionState.AwaitingChallenge, ConnectStatus.NoChallengeReceived);
                    }
                    break;
                case ConnectionState.AwaitingConnected:
                    if (CheckResend())
                    {
                        SendSolution();
                    }
                    else
                    {
                        ConnectFailed(ConnectionState.AwaitingConnected, ConnectStatus.NoConnectedReceived);
                    }
                    break;
            }
        }

        /// <summary>
        /// Checks the retry count to determine if a connection packet can be resent
        /// </summary>
        /// <returns></returns>
        private bool CheckResend()
        {
            int count = retryCount;
            if (Interlocked.CompareExchange(ref retryCount, count + 1, count) == count)
            {
                return retryCount < Connection_Retry_Amount;
            }
            return false;
        }

        #endregion

        #region Connection

        /// <summary>
        /// Connects to a given string ip address and port
        /// </summary>
        /// <param name="ip"></param>
        /// <param name="port"></param>
        public void Connect(string ip, int port)
        {
            Connect(new IPEndPoint(IPAddress.Parse(ip), port));
        }

        /// <summary>
        /// Connects to a given ip and port
        /// </summary>
        /// <param name="ip"></param>
        /// <param name="port"></param>
        public void Connect(long ip, int port)
        {
            Connect(new IPEndPoint(ip, port));
        }

        /// <summary>
        /// Connects to a given EndPoint
        /// </summary>
        /// <param name="endpoint"></param>
        public void Connect(EndPoint endpoint)
        {
            // return if already started connection process
            if (!SetConnectionState(ConnectionState.AwaitingChallenge, ConnectionState.ReadyToConnect)) return;
            remoteEndPoint = endpoint;
            socket.Bind(new IPEndPoint(IPAddress.Any, 0));
            localSalt = Udp.GenerateLocalSalt();
            timer.Start();
            StartRead();
            SendConnect();
        }

        /// <summary>
        /// Sends the connection request packet
        /// </summary>
        private void SendConnect()
        {
            SendUdp(new UdpConnect(localSalt));
        }

        /// <summary>
        /// Sends the connection solution packet
        /// </summary>
        private void SendSolution()
        {
            SendUdp(new UdpSolution(salt));
        }

        /// <summary>
        /// Called when this client is connected to a remote host
        /// </summary>
        protected abstract void HandleConnected(ConnectStatus status);

        /// <summary>
        /// Sets the connection state from a previous state, and returns true if successful
        /// </summary>
        /// <returns><c>true</c>, if connection state was set, <c>false</c> otherwise.</returns>
        /// <param name="newState">New state.</param>
        /// <param name="fromState">From state.</param>
        private bool SetConnectionState(ConnectionState newState, ConnectionState fromState)
        {
            return Interlocked.CompareExchange(ref state, (int)newState, (int)fromState) == (int)fromState;
        }

        /// <summary>
        /// Sets the connection state atomically
        /// </summary>
        /// <param name="newState">New state.</param>
        private ConnectionState SetConnectionState(ConnectionState newState)
        {
            return (ConnectionState)Interlocked.Exchange(ref state, (int)newState);
        }

        /// <summary>
        /// Disconnect client from the virtual connection
        /// </summary>
        /// <returns>The disconnect.</returns>
        public bool Disconnect(bool initiate = true)
        {
            if (Interlocked.CompareExchange(ref disconnected, 1, 0) == 1) return false; // return if this method was already called
            var currentState = SetConnectionState(ConnectionState.Disconnected);
            switch (currentState)
            {
                case ConnectionState.Connected:
                    if (initiate)
                    {
                        SendUdp(new UdpDisconnect(salt, UdpDisconnectReason.ClientDisconnect)); // only send if already connected and initiating the disconnect
                    }
                    HandleDisconnect();
                    socket.Close();
                    break;
                case ConnectionState.AwaitingChallenge:
                case ConnectionState.AwaitingConnected:
                    ConnectFailed(ConnectionState.Disconnected, ConnectStatus.Disconnect);
                    return true;
            }

            timer.Stop();
            return true;
        }

        /// <summary>
        /// Connection failed if the current state equals the given state
        /// </summary>
        /// <param name="state"></param>
        /// <param name="status"></param>
        private void ConnectFailed(ConnectionState state, ConnectStatus status)
        {
            if (State != state) return;
            SetConnectionState(ConnectionState.ReadyToConnect);
            retryCount = 0;
            timer.Stop();
            HandleConnected(status);
        }

        /// <summary>
        /// Called once upon disconnect
        /// </summary>
        protected abstract void HandleDisconnect();

        #endregion

        #region Reading

        /// <summary>
        /// Starts reading for incoming packets
        /// </summary>
        public void StartRead()
        {
            BeginRead();
        }

        /// <summary>
        /// Starts reading for incoming packets
        /// </summary>
        private void BeginRead()
        {
            socket.BeginReceiveFrom(buffer.data, 0, Max_Packet_Size, SocketFlags.None, ref remoteEndPoint, OnRead, state);
        }

        /// <summary>
        /// Read callback
        /// </summary>
        /// <param name="ar"></param>
        private void OnRead(IAsyncResult ar)
        {
            int length = socket.EndReceiveFrom(ar, ref remoteEndPoint);

            // TODO handle failed read or socket closed

            try
            {
                BitReader r = new BitReader(buffer.data, length);
                bool isUdp = r.ReadBool();
                byte id;
                if (isUdp)
                {
                    id = r.ReadUInt8();
                    var udpPacket = Udp.CreateUdpPacket(id);
                    if (udpPacket == null) return;
                    udpPacket.ReadPacket(r);
                    HandleUdpPacket(udpPacket);
                    return;
                }

                ulong receivedSalt = r.ReadUInt64();
                if (receivedSalt != salt) return; // salt mismatch

#if DEBUG
                if (Rand.Next(10000) / 100.0 < Simulate_Packet_Loss_Percent)
                {
                    Log.Error("Stopped packet: " + r.ReadUInt16());
                    return;
                }
#endif

                var header = ReadHeader(r); // process header
                if (!HandlePacketHeader(header)) return;

                id = r.ReadUInt8(); // read packet payload
                TPacket packet = packetFactory.CreatePacket(id);
                if (packet == null)
                {
                    Log.Error($"No {typeof(TPacket).Name} for id: {id}");
                    return;
                }
                packet.ReadPacket(r);
                HandlePacket(packet);
            }
            finally
            {
                BeginRead();
            }
        }

        /// <summary>
        /// Handles a received packet header
        /// </summary>
        /// <param name="header"></param>
        private bool HandlePacketHeader(PacketHeader header)
        {
            Log.Write("Received seq id: " + header.sequenceId);
            HandleReceivedBitfield(header.lastReceivedId, header.receivedBitfield);
            return HandleSequenceId(header.sequenceId);
        }

        /// <summary>
        /// Handles remote's sequence id and logs the receive info in the local bitfield
        /// </summary>
        /// <param name="sequenceId"></param>
        /// <returns></returns>
        private bool HandleSequenceId(ushort sequenceId)
        {
            lock (sequenceLock)
            {
                var currentId = lastReceivedSequenceId;
                var currentBitfield = receivedBitfield;
                if (lastReceivedSequenceId == sequenceId) return false; // already processed this

                var dif = GetSequenceDifference(currentId, sequenceId);

                if (dif > 0) // advance sequence packet
                {
                    lastReceivedSequenceId = sequenceId;
                    if (dif == 32)
                    {
                        receivedBitfield = (uint)1 << 31;
                    }
                    else if (dif <= 32)
                    {
                        receivedBitfield = (receivedBitfield << dif) | ((uint)1 << (dif - 1));
                    }
                    else
                    {
                        receivedBitfield = 0;
                    }

                    return true;
                }
                else // don't advance sequence
                {
                    dif = -dif;
                    if (dif <= 32)
                    {
                        bool alreadyProcessed = ((receivedBitfield >> (dif - 1)) & 1) == 1;
                        if (alreadyProcessed) return false; // already received / processed
                        receivedBitfield |= (uint)1 << (dif - 1);
                        return true;
                    }
                    return false;
                }
            }
        }

        /// <summary>
        /// Handles the header information regarding remote received packets
        /// </summary>
        /// <param name="lastReceivedId"></param>
        /// <param name="bitfield"></param>
        private void HandleReceivedBitfield(ushort lastReceivedId, uint bitfield)
        {
            Packet dummy;
            if (sentPackets.TryRemove(lastReceivedId, out dummy))
                Log.Write("Packet confirmed: " + lastReceivedId);
            foreach (var packet in sentPackets.ToArray())
            {
                var dif = GetSequenceDifference(packet.Key, lastReceivedId);
                if (dif > 32) // packet lost
                {
                    sentPackets.TryRemove(packet.Key, out dummy);
                    Log.Write($"Packet {packet.Value.GetType().Name} ({packet.Key}) lost, resending", ConsoleColor.Green);
                    Send(packet.Value); // TODO implement congestion control
                }
                else if (dif > 0 && ((bitfield >> (dif - 1)) & 1) == 1) // packet received successfully
                {
                    sentPackets.TryRemove(packet.Key, out dummy);
                    Log.Write("Packet confirmed: " + packet.Key);
                }
            }
        }

        /// <summary>
        /// Returns the difference between two sequence id's
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        private int GetSequenceDifference(ushort from, ushort to)
        {
            if (to == from) return 0;

            int highDif;
            if (to < from)
                highDif = to + (ushort.MaxValue - from);
            else
                highDif = to - from;

            if (highDif > ushort.MaxValue / 2)
            {
                int lowDif;
                if (from < to)
                    lowDif = from + (ushort.MaxValue - to) + 1;
                else
                    lowDif = from - from;
                return -lowDif;
            }
            else
                return highDif;
        }

        /// <summary>
        /// Reads a packet header from a given BitReader
        /// </summary>
        /// <param name="r"></param>
        /// <returns></returns>
        private PacketHeader ReadHeader(BitReader r)
        {
            return new PacketHeader(r);
        }

        /// <summary>
        /// Handles a received packet
        /// </summary>
        /// <param name="packet">Packet.</param>
        protected abstract void HandlePacket(TPacket packet);

        /// <summary>
        /// Handles a received UdpPacket
        /// </summary>
        /// <param name="packet">Packet.</param>
        private void HandleUdpPacket(UdpPacket packet)
        {
            var currentState = State;
            switch (packet.Type)
            {
                case UdpPacketType.Challenge:
                    HandleChallenge((UdpChallenge)packet);
                    break;
                case UdpPacketType.Connected:
                    HandleConnected((UdpConnected)packet);
                    break;
                case UdpPacketType.Disconnect:
                    HandleDisconnect((UdpDisconnect)packet);
                    break;
            }
        }

        /// <summary>
        /// Responds to a challenge packet received from the remote server
        /// </summary>
        /// <param name="challenge">Challenge.</param>
        private void HandleChallenge(UdpChallenge challenge)
        {
            if (challenge.clientSalt != localSalt) return; // salt mismatch, could be spoofed sender
            if (!SetConnectionState(ConnectionState.AwaitingConnected, ConnectionState.AwaitingChallenge)) return;
            remoteSalt = challenge.serverSalt;
            salt = Udp.CreateSalt(localSalt, remoteSalt);
            retryCount = 0;
            SendSolution();
        }

        /// <summary>
        /// Handles a connected packet received from the remote host
        /// </summary>
        /// <param name="connected"></param>
        private void HandleConnected(UdpConnected connected)
        {
            if (connected.salt != salt) // salt mismatch, could be spoofed sender
            {
                Log.Write("UdpClient, invalid salt received in solution packet");
                return;
            }
            if (!SetConnectionState(ConnectionState.Connected, ConnectionState.AwaitingConnected)) return;
            remoteEndPoint = new IPEndPoint(((IPEndPoint)remoteEndPoint).Address, connected.port);
            retryCount = 0;
            HandleConnected(ConnectStatus.Success);
        }

        private void HandleDisconnect(UdpDisconnect disconnect)
        {
            Disconnect(false);
            Log.Error("Server disconnected client: " + disconnect.ReasonString);
        }

        #endregion

        #region Sending

        /// <summary>
        /// Sends a given packet
        /// </summary>
        /// <param name="packet">Packet.</param>
        public void Send(Packet packet)
        {
            Send(new UdpSendData(packet, false));
        }

        /// <summary>
        /// Sends a given udp packet
        /// </summary>
        /// <param name="packet"></param>
        private void SendUdp(UdpPacket packet)
        {
            Send(new UdpSendData(packet, true));
        }

        /// <summary>
        /// Sends data or adds it to a queue if already sending
        /// </summary>
        /// <param name="data"></param>
        private void Send(UdpSendData data)
        {
            lock (sendSync)
            {
                if (sending)
                {
                    sendQueue.Enqueue(data);
                    return;
                }
                sending = true;
            }

            SendPacket(data);
        }

        /// <summary>
        /// Sends a packet to the remote
        /// </summary>
        /// <param name="packet">Packet.</param>
        private void SendPacket(UdpSendData packet)
        {
            Log.Write("Sending: " + packet.packet.GetType().Name);
            lastSent = DateTime.Now;
            var package = PackagePacket(packet);
            socket.BeginSendTo(package.data, 0, package.size, SocketFlags.None, remoteEndPoint, OnSend, null);
        }

        /// <summary>
        /// Callback function for socket send calls
        /// </summary>
        /// <param name="ar">Ar.</param>
        private void OnSend(IAsyncResult ar)
        {
            int sent = socket.EndSendTo(ar);

            UdpSendData nextPacket;
            lock (sendSync)
            {
                if (sendQueue.Count == 0)
                {
                    sending = false;
                    return;
                }
                nextPacket = sendQueue.Dequeue();
            }

            SendPacket(nextPacket);
        }

        /// <summary>
        /// Packages a packet into a buffer to send
        /// </summary>
        /// <returns>The packet.</returns>
        /// <param name="data">The packet data to send</param>
        private IO.Buffer PackagePacket(UdpSendData data)
        {
            var w = new BitWriter();
            w.Write(data.udp);
            if (!data.udp)
            {
                w.Write(salt);
                ushort seq = WriteHeader(w);
                Log.Write("Sending seq id: " + seq);
                sentPackets[seq] = data.packet;
            }
            w.Write(data.packet.Id);
            data.packet.WritePacket(w);
            return w.GetData();
        }

        /// <summary>
        /// Writes the Udp packet header
        /// </summary>
        private ushort WriteHeader(BitWriter w)
        {
            ushort seq = ++nextSequenceId;
            w.Write(seq);
            GetReceivedInfo(out ushort latest, out uint bitfield);
            w.Write(latest);
            w.Write(bitfield);
            return seq;
        }

        /// <summary>
        /// Gets the received information atmoically
        /// </summary>
        /// <param name="latest"></param>
        /// <param name="bitfield"></param>
        private void GetReceivedInfo(out ushort latest, out uint bitfield)
        {
            lock (sequenceLock)
            {
                latest = lastReceivedSequenceId;
                bitfield = receivedBitfield;
            }
        }

        #endregion
    }
}
