using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using Utils.NET.IO;
using Utils.NET.Logging;
using Utils.NET.Net.Udp.Packets;

namespace Utils.NET.Net.Udp
{
    public abstract class UdpClient<TPacket> where TPacket : Packet
    {
        private enum ConnectionState
        {
            ReadyToConnect = 0,
            Connected = 1,
            AwaitingChallange = 2,
            AwaitingConnected = 3,
            Disconnected = 4
        }

        private class SendData
        {
            public Packet packet;
            public bool udp;

            public SendData(Packet packet, bool udp)
            {
                this.packet = packet;
                this.udp = udp;
            }
        }

        private const int Max_Packet_Size = 512;

        /// <summary>
        /// Underlying system socket used to send and receive data
        /// </summary>
        private Socket socket;

        /// <summary>
        /// The EndPoint that this client is connecting or connected to
        /// </summary>
        private EndPoint remoteEndPoint;

        /// <summary>
        /// The state of the virtual connection
        /// </summary>
        private int state = 0;

        /// <summary>
        /// The current connection state of the client
        /// </summary>
        /// <value>The state.</value>
        private ConnectionState State => (ConnectionState)state;

        /// <summary>
        /// Factory used to create packets
        /// </summary>
        private PacketFactory<TPacket> packetFactory;

        /// <summary>
        /// Buffer used to hold received data
        /// </summary>
        private IO.Buffer buffer;

        /// <summary>
        /// Object used to sync sending states
        /// </summary>
        private object sendSync = new object();

        /// <summary>
        /// Bool determining if the client is currently sending
        /// </summary>
        private bool sending = false;

        /// <summary>
        /// Queue used to store data ready to send
        /// </summary>
        private Queue<SendData> sendQueue = new Queue<SendData>();

        /// <summary>
        /// Value used to syncronize disconnection calls
        /// </summary>
        private int disconnected = 0;

        /// <summary>
        /// Salt generated locally
        /// </summary>
        private ulong localSalt;

        /// <summary>
        /// Salt generated by the server
        /// </summary>
        private ulong remoteSalt;

        /// <summary>
        /// Generated salt from server/client
        /// </summary>
        private ulong salt;

        #region Init

        protected UdpClient()
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            Init();
        }

        protected UdpClient(Socket socket)
        {
            this.socket = socket;
            Init();
        }

        private void Init()
        {
            packetFactory = new PacketFactory<TPacket>();
            buffer = new IO.Buffer(Max_Packet_Size);
        }

        #endregion

        #region Connection

        /// <summary>
        /// Connects to a given string ip address and port
        /// </summary>
        /// <param name="ip"></param>
        /// <param name="port"></param>
        public void Connect(string ip, int port)
        {
            Connect(new IPEndPoint(IPAddress.Parse(ip), port));
        }

        /// <summary>
        /// Connects to a given ip and port
        /// </summary>
        /// <param name="ip"></param>
        /// <param name="port"></param>
        public void Connect(long ip, int port)
        {
            Connect(new IPEndPoint(ip, port));
        }

        /// <summary>
        /// Connects to a given EndPoint
        /// </summary>
        /// <param name="endpoint"></param>
        public void Connect(EndPoint endpoint)
        {
            // return if already started connection process
            if (!SetConnectionState(ConnectionState.AwaitingChallange, ConnectionState.ReadyToConnect)) return;
            remoteEndPoint = endpoint;
            socket.Bind(new IPEndPoint(IPAddress.Any, 0));
            localSalt = Udp.GenerateLocalSalt();
            SendUdp(new UdpConnect(localSalt));
        }

        /// <summary>
        /// Sets the connection state from a previous state, and returns true if successful
        /// </summary>
        /// <returns><c>true</c>, if connection state was set, <c>false</c> otherwise.</returns>
        /// <param name="newState">New state.</param>
        /// <param name="fromState">From state.</param>
        private bool SetConnectionState(ConnectionState newState, ConnectionState fromState)
        {
            return Interlocked.CompareExchange(ref state, (int)newState, (int)fromState) == (int)fromState;
        }

        /// <summary>
        /// Sets the connection state atomically
        /// </summary>
        /// <param name="newState">New state.</param>
        private ConnectionState SetConnectionState(ConnectionState newState)
        {
            return (ConnectionState)Interlocked.Exchange(ref state, (int)newState);
        }

        /// <summary>
        /// Disconnect client from the virtual connection
        /// </summary>
        /// <returns>The disconnect.</returns>
        public bool Disconnect()
        {
            if (Interlocked.CompareExchange(ref disconnected, 1, 0) == 1) return false; // return if this method was already called
            if (SetConnectionState(ConnectionState.Disconnected) == ConnectionState.Connected)
            {
                SendUdp(new UdpDisconnect(salt)); // only send if already connected
            }
            DoDisconnect();
            return true;
        }

        protected virtual void DoDisconnect()
        {
            HandleDisconnect();
            socket.Close();
        }

        /// <summary>
        /// Called once upon disconnect
        /// </summary>
        protected abstract void HandleDisconnect();

        #endregion

        #region Reading

        /// <summary>
        /// Starts reading for incoming packets
        /// </summary>
        public void StartRead()
        {
            if (State != ConnectionState.Connected) return;
            BeginRead();
        }

        /// <summary>
        /// Starts reading for incoming packets
        /// </summary>
        private void BeginRead()
        {
            socket.BeginReceiveFrom(buffer.data, 0, Max_Packet_Size, SocketFlags.None, ref remoteEndPoint, OnRead, state);
        }

        /// <summary>
        /// Read callback
        /// </summary>
        /// <param name="ar"></param>
        private void OnRead(IAsyncResult ar)
        {
            int length = socket.EndReceiveFrom(ar, ref remoteEndPoint);

            byte[] data = buffer.data;
            BitReader r = new BitReader(data, length);
            bool isUdp = r.ReadBool();
            byte id = r.ReadUInt8();
            if (isUdp)
            {
                var udpPacket = CreateUdpPacket(id);
                udpPacket.ReadPacket(r);
                HandleUdpPacket(udpPacket);
                return;
            }

            TPacket packet = packetFactory.CreatePacket(id);
            if (packet == null)
            {
                Log.Error($"No {typeof(TPacket).Name} for id: {id}");
                return;
            }
            packet.ReadPacket(r);
            HandlePacket(packet);
        }

        /// <summary>
        /// Handles a received packet
        /// </summary>
        /// <param name="packet">Packet.</param>
        protected abstract void HandlePacket(TPacket packet);

        /// <summary>
        /// Handles a received UdpPacket
        /// </summary>
        /// <param name="packet">Packet.</param>
        private void HandleUdpPacket(UdpPacket packet)
        {
            var currentState = State;
            switch (packet.Type)
            {
                case UdpPacketType.Challenge:
                    RespondToChallenge((UdpChallenge)packet);
                    break;
                case UdpPacketType.AwaitingState:
                    if (currentState != ConnectionState.Connected) return;
                    break;
            }
        }

        /// <summary>
        /// Creates a UdpPacket from a given type id
        /// </summary>
        /// <returns>The UDP packet.</returns>
        /// <param name="id">Identifier.</param>
        private UdpPacket CreateUdpPacket(byte id)
        {
            switch ((UdpPacketType)id)
            {
                case UdpPacketType.Connect:
                    return new UdpConnect();
                case UdpPacketType.Challenge:
                    return new UdpChallenge();
                case UdpPacketType.Solution:
                    return new UdpSolution();
                case UdpPacketType.Disconnect:
                    return new UdpDisconnect();
                case UdpPacketType.AwaitingState:
                    return new UdpAwaitingState();
            }
            return null;
        }

        /// <summary>
        /// Responds to a challenge packet received from the remote server
        /// </summary>
        /// <param name="challenge">Challenge.</param>
        private void RespondToChallenge(UdpChallenge challenge)
        {
            if (challenge.clientSalt != localSalt) return; // salt mismatch, could be spoofed sender
            if (State == ConnectionState.AwaitingChallange)
            {
                if (!SetConnectionState(ConnectionState.Connected, ConnectionState.AwaitingChallange)) return;
                remoteSalt = challenge.serverSalt;
                salt = Udp.CreateSalt(localSalt, remoteSalt);
            }
            SendUdp(new UdpSolution(salt));
        }

        #endregion

        #region Sending

        /// <summary>
        /// Sends a given packet
        /// </summary>
        /// <param name="packet">Packet.</param>
        public void Send(TPacket packet)
        {
            Send(new SendData(packet, false));
        }

        /// <summary>
        /// Sends a given udp packet
        /// </summary>
        /// <param name="packet"></param>
        private void SendUdp(UdpPacket packet)
        {
            Send(new SendData(packet, true));
        }

        private void Send(SendData data)
        {
            lock (sendSync)
            {
                if (sending)
                {
                    sendQueue.Enqueue(data);
                    return;
                }
                sending = true;
            }

            SendPacket(data);
        }

        /// <summary>
        /// Sends a packet to the remote 
        /// </summary>
        /// <param name="packet">Packet.</param>
        private void SendPacket(SendData packet)
        {
            var package = PackagePacket(packet);
            socket.BeginSendTo(package.data, 0, package.size, SocketFlags.None, remoteEndPoint, OnSend, null);
        }

        /// <summary>
        /// Callback function for socket send calls
        /// </summary>
        /// <param name="ar">Ar.</param>
        private void OnSend(IAsyncResult ar)
        {
            int sent = socket.EndSendTo(ar);

            SendData nextPacket;
            lock (sendSync)
            {
                if (sendQueue.Count == 0)
                {
                    sending = false;
                    return;
                }
                nextPacket = sendQueue.Dequeue();
            }

            SendPacket(nextPacket);
        }

        /// <summary>
        /// Packages a packet into a buffer to send
        /// </summary>
        /// <returns>The packet.</returns>
        /// <param name="data">The packet data to send</param>
        private IO.Buffer PackagePacket(SendData data)
        {
            var w = new BitWriter();
            w.Write(data.udp);
            data.packet.WritePacket(w);
            return w.GetData();
        }

        #endregion
    }
}
